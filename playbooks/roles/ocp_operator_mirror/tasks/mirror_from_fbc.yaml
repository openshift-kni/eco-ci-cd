- name: Set extract directory path
  ansible.builtin.set_fact:
    extract_dir: "{{ ocp_operator_mirror_fbc_extract_dir }}/{{ operator.name }}-{{ ocp_operator_mirror_version }}"
  changed_when: false

- name: Remove extract directory if present
  ansible.builtin.file:
    path: "{{ extract_dir }}"
    state: absent

- name: Create extract directory
  ansible.builtin.file:
    path: "{{ extract_dir }}"
    state: directory
    mode: '0755'

- name: Compute FBC tag
  changed_when: false
  ansible.builtin.set_fact:
    fbc_tag: >-
      {{
        operator.fbc_iib_repo
        if (((operator.ocp_operator_mirror_fbc_image_base | default('')) | length) > 0)
        else 'ocp__' ~ ocp_operator_mirror_version ~ '__' ~ operator.fbc_iib_repo
      }}

- name: Remove FBC index image (if present)
  containers.podman.podman_image:
    name: "{{ operator.ocp_operator_mirror_fbc_image_base | default(ocp_operator_mirror_fbc_image_base) }}"
    tag: "{{ fbc_tag }}"
    state: absent
    force: true

- name: Pull FBC index image
  containers.podman.podman_image:
    name: "{{ operator.ocp_operator_mirror_fbc_image_base | default(ocp_operator_mirror_fbc_image_base) }}"
    tag: "{{ fbc_tag }}"
    state: present
    force: true

- name: Mirror FBC index image to internal registry (if missing)
  changed_when: true
  ansible.builtin.command: >-
    skopeo copy --all --retry-times 3 --authfile "{{ ocp_operator_mirror_pull_secret_path }}"
    "docker://{{ operator.ocp_operator_mirror_fbc_image_base | default(ocp_operator_mirror_fbc_image_base) }}:{{ fbc_tag }}"
    "docker://{{ ocp_operator_mirror_registry_url }}/{{ ocp_operator_mirror_folder }}/{{ operator.fbc_iib_repo }}"

- name: Create temporary container
  containers.podman.podman_container:
    name: "{{ ocp_operator_mirror_fbc_tmp_container_prefix }}{{ operator.fbc_iib_repo }}"
    image: "{{ (operator.ocp_operator_mirror_fbc_image_base | default(ocp_operator_mirror_fbc_image_base)) }}:{{ fbc_tag }}"
    state: created

- name: Copy /configs from container
  ansible.builtin.command:
    argv:
      - podman
      - cp
      - "{{ ocp_operator_mirror_fbc_tmp_container_prefix }}{{ operator.fbc_iib_repo }}:/configs"
      - "{{ extract_dir }}/"
  changed_when: true

- name: Remove temporary container
  containers.podman.podman_container:
    name: "{{ ocp_operator_mirror_fbc_tmp_container_prefix }}{{ operator.fbc_iib_repo }}"
    state: absent

- name: Find package directory under /configs
  ansible.builtin.find:
    paths: "{{ extract_dir }}/configs"
    file_type: directory
    depth: 1
  register: fbc_pkg_dirs

- name: Fail if package directory count is not 1
  ansible.builtin.fail:
    msg: "Expected exactly one directory under /configs in {{ fbc_image }}, found {{ fbc_pkg_dirs.matched | default(0) }}"
  when: (fbc_pkg_dirs.matched | default(0)) | int != 1

- name: Set package directory path
  ansible.builtin.set_fact:
    fbc_pkg_catalog_dir: "{{ (fbc_pkg_dirs.files | first).path }}"

- name: Check if catalog.json exists
  ansible.builtin.stat:
    path: "{{ fbc_pkg_catalog_dir }}/catalog.json"
  register: json_catalog

- name: Check if catalog.yaml already exists
  ansible.builtin.stat:
    path: "{{ fbc_pkg_catalog_dir }}/catalog.yaml"
  register: yaml_catalog

- name: Convert catalog.json to catalog.yaml
  when: json_catalog.stat.exists and not yaml_catalog.stat.exists
  block:
    - name: Read the catalog.json file
      ansible.builtin.slurp:
        src: "{{ fbc_pkg_catalog_dir }}/catalog.json"
      register: remote_json_file

    - name: Convert JSON stream to YAML and save
      ansible.builtin.copy:
        dest: "{{ fbc_pkg_catalog_dir }}/catalog.yaml"
        content: |
          {% set raw = remote_json_file.content | b64decode | trim %}
          {% for item in ('[' + (raw | regex_replace('}\s*{', '}, {')) + ']') | from_json %}
          ---
          {{ item | to_nice_yaml(indent=2) }}
          {% endfor %}

- name: Set catalog.yaml path
  ansible.builtin.set_fact:
    catalog_path: "{{ fbc_pkg_catalog_dir }}/catalog.yaml"

- name: Read catalog.yaml
  ansible.builtin.slurp:
    src: "{{ catalog_path }}"
  register: cat

- name: Parse catalog.yaml into documents
  changed_when: false
  ansible.builtin.set_fact:
    docs: "{{ (cat.content | b64decode) | from_yaml_all | list }}"

- name: Detect package name from catalog
  changed_when: false
  ansible.builtin.set_fact:
    package: "{{ (docs | selectattr('schema', 'equalto', 'olm.package') | map(attribute='name') | first) }}"

- name: Assert package is present in catalog
  ansible.builtin.assert:
    that:
      - package is defined
      - package | length > 0
    fail_msg: "No package found in catalog. Packages seen: {{ docs | selectattr('schema', 'equalto', 'olm.package') | map(attribute='name') | list }}"

- name: Collect all entry names for package/channel
  changed_when: false
  ansible.builtin.set_fact:
    entry_names: >-
      {{
        (docs
          | selectattr('schema','equalto','olm.channel')
          | selectattr('package','equalto', package)
          | selectattr('name','equalto', operator.channel)
          | map(attribute='entries') | first | default([])
          | map(attribute='name') | list)
      }}

- name: Ensure channel has entries
  ansible.builtin.assert:
    that:
      - (entry_names | default([])) | length > 0
    fail_msg: >-
      No entries for package '{{ package }}' channel '{{ operator.channel }}'.
      Available channels: {{
        docs | selectattr('schema','equalto','olm.channel')
             | selectattr('package','equalto', package)
             | map(attribute='name') | list
      }}

- name: Filter entry names by version substring (optional)
  changed_when: false
  ansible.builtin.set_fact:
    filtered_names: >-
      {{
        (entry_names | select('search', ocp_operator_mirror_bundle_version) | list)
        if (ocp_operator_mirror_bundle_version is defined and (ocp_operator_mirror_bundle_version | length) > 0)
        else entry_names
      }}

- name: Ensure version filter matches at least one entry
  ansible.builtin.fail:
    msg: "No bundle entry matched version filter '{{ ocp_operator_mirror_bundle_version }}' in channel '{{ operator.channel }}'"
  when: filtered_names | length == 0

- name: Select bundle (latest or filtered)
  changed_when: false
  ansible.builtin.set_fact:
    chosen_name: "{{ (filtered_names | sort | last) }}"

- name: Collect images from selected bundle
  changed_when: false
  ansible.builtin.set_fact:
    chosen_images: >-
      {{
        (docs
        | selectattr('schema','equalto','olm.bundle')
        | selectattr('name','equalto', chosen_name))
        | first
        | combine({})
        | dict2items
        | selectattr('key','in',['image','relatedImages'])
        | map(attribute='value')
      }}

- name: Build unique image list
  changed_when: false
  ansible.builtin.set_fact:
    image_list: "{{ ([chosen_images.0] + ((chosen_images.1 | default([])) | map(attribute='image') | list)) | unique }}"

- name: Rewrite image registries to stage (registry.redhat.io -> registry.stage.redhat.io)
  changed_when: false
  ansible.builtin.set_fact:
    image_list: "{{ image_list | map('regex_replace', '^registry\\.redhat\\.io/', 'registry.stage.redhat.io/') | list }}"
  when: "((operator.ocp_operator_mirror_fbc_image_base | default('')) | length) > 0"

- name: Collect unique source repositories (strip digests)
  changed_when: false
  ansible.builtin.set_fact:
    source_repos: "{{ image_list | map('regex_replace', '@.*', '') | list | unique }}"

- name: Select source repositories for mirror mapping
  changed_when: false
  ansible.builtin.set_fact:
    loop_source_repos: >-
      {{
        (source_repos | map('replace', 'registry.stage.redhat.io', 'registry.redhat.io') | list)
        if (((operator.ocp_operator_mirror_fbc_image_base | default('')) | length) > 0)
        else source_repos
      }}

- name: Set mirror mapping for each repository
  changed_when: false
  ansible.builtin.set_fact:
    image_digest_mirrors: >-
      {{
        (image_digest_mirrors | default([]))
        + [ {
          'source': item,
          'mirrors': [
            item | regex_replace('^[^/]+', ocp_operator_mirror_registry_url)
          ]
        } ]
      }}
  loop: "{{ loop_source_repos }}"

- name: Apply ImageDigestMirrorSet for fbc images
  kubernetes.core.k8s:
    state: present
    definition:
      apiVersion: config.openshift.io/v1
      kind: ImageDigestMirrorSet
      metadata:
        name: "operators-fbc-mirror-{{ operator.name }}"
      spec:
        imageDigestMirrors: "{{ image_digest_mirrors }}"
    kubeconfig: "{{ ocp_operator_mirror_kubeconfig | default(omit) }}"

- name: Build source/destination image pairs (map prod digest to FBC share; preserve original repo for destination)
  changed_when: false
  ansible.builtin.set_fact:
    image_pairs: >-
      {{
        (image_pairs | default([])) + [
          {
            'src': (image
                    if (((operator.ocp_operator_mirror_fbc_image_base | default('')) | length) > 0)
                    else ((image | regex_search('@sha256:[0-9a-f]{64}'))
                          | ternary(ocp_operator_mirror_art_images_share ~ (image | regex_search('@sha256:[0-9a-f]{64}')), image)))
            ,
            'dst': (image | regex_replace('^([^/]+)', ocp_operator_mirror_registry_url))
          }
        ]
      }}
  loop: "{{ image_list }}"
  loop_control:
    loop_var: image
    label: "{{ image }}"

- name: Ensure CatalogSource for mirrored index is present
  kubernetes.core.k8s:
    kubeconfig: "{{ ocp_operator_mirror_kubeconfig }}"
    state: present
    definition:
      apiVersion: operators.coreos.com/v1alpha1
      kind: CatalogSource
      metadata:
        name: "{{ operator.catalog }}"
        namespace: "openshift-marketplace"
      spec:
        sourceType: grpc
        image: "{{ ocp_operator_mirror_registry_url }}/{{ ocp_operator_mirror_folder }}/{{ operator.fbc_iib_repo }}"
